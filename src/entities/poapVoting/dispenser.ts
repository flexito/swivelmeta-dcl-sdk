import * as utils from '@dcl/ecs-scene-utils'
import * as UI from '@dcl/ui-scene-utils'
import { getUserData, UserData } from '@decentraland/Identity'
import { getCurrentRealm, Realm } from '@decentraland/EnvironmentAPI'
import { signedFetch } from '@decentraland/SignedFetch'

import * as boothUI from './ui'
import { default as resources } from './resources'
import { AirtableClient } from './airtable_api'
import { EnableDisable, debugMessage } from "../../index";


export const sceneMessageBus = new MessageBus()
export const bEnablePoapClaim = new EnableDisable() // defaults to true, this is the class that handles the enable/disable of the POAP claim
const timeDelay = 1 *60 *1000 // Delay before being able to claim a POAP in milliseconds

// set aliases for the resources
const dispenser = resources.dispenser
const button = resources.button
const sounds = resources.sounds

// set type for animation states objects
type AnimStates = {
    [key: string]: AnimationState
}

/**
 * It is a booth that users can interact with to vote and claim a POAP token. 
 * The booth will display the number of votes for the person/object that users are voting for.
 * Only one Vote/POAP token can be claimed per user.
 * 
 * @param {TransformConstructorArgs} transform position, rotation and scale of the booth.
 * @param {string} voteName Name of the person/object that users are voting for.
 * @param { number } voteID  ID of the vote, used for counting the votes.
 * @param {string} poapServer server to use. Defaults to 'poap-api.decentraland.org'
 * @param {string} eventUUID The POAP event UUID, generated by Decentraland POAP server.
 * More info can be found here: https://docs.decentraland.org/creator/development-guide/poap-tokens/
 */
export class PoapVoteDispenser extends Entity {
  public AirtableClient: AirtableClient;
  public voteName: string;
  public voteID: number;

  public eventUUID: string;
  public poapServer: string;
  public createdTime: Date;
  
  public counterTextEntity: Entity;
  public displayNameEntity: Entity;

  public dispenserShape: GLTFShape = dispenser.dispenserShape;
  public dispenserAnimator: Animator = dispenser.dispenserAnimator;
  public dispenserAnims = dispenser.dispenserAnims;
  public buttonEntity: Entity;
  public buttonShape: GLTFShape = button.buttonShape;
  public buttonAnimator: Animator = button.buttonAnimator;
  public buttonAnims: AnimStates = button.buttonAnims;
  
  public count: string = '0';
  public readonly testing: boolean;
  private bAlreadyAttempted: boolean;

  constructor(
    { 
      transform, 
      AirtableClient, 
      voteName, voteID, 
      eventUUID, 
      testing, 
      poapServer 
    }: { 
      transform: TranformConstructorArgs; 
      AirtableClient: AirtableClient; 
      voteName: string; 
      voteID: number; 
      eventUUID: string; 
      testing?: boolean; 
      poapServer?: string 
    }
  ) {
    super();

    // Set up the class variables
    this.AirtableClient = AirtableClient;
    this.voteName = voteName;
    this.voteID = voteID;
    this.eventUUID = eventUUID;
    this.poapServer = poapServer ? poapServer : 'poap-api.decentraland.org';
    this.testing = testing ? testing : false;
    this.createdTime = new Date();
    this.bAlreadyAttempted = false;

    engine.addEntity(this);
    this.addComponent(new Transform(transform));


    // Create Text to display the number of votes
    this.counterTextEntity = new Entity();
    this.counterTextEntity.setParent(this);
    this.counterTextEntity.addComponent(
      new Transform({
        position: new Vector3(0, 3, 0),
        scale: new Vector3(0.5, 0.5, 0.5),
      }));
    this.counterTextEntity.addComponent(new TextShape(this.count));
    this.counterTextEntity.getComponent(TextShape).color = Color3.Red();


    // Create Text to display the name of the person/object that users are voting for
    this.displayNameEntity = new Entity();
    this.displayNameEntity.setParent(this);
    this.displayNameEntity.addComponent(
      new Transform({
        position: new Vector3(0, 4, 0),
        rotation: Quaternion.Euler(0, 180, 0),
        scale: new Vector3(0.25, 0.25, 0.25),
      })
    );
    this.displayNameEntity.addComponent(new TextShape(this.voteName));
    this.displayNameEntity.getComponent(TextShape).color = Color3.White();


    // Create the dispenser shape
    this.addComponent(this.dispenserShape);
    // Add the animator component and the dispenser animation
    this.addComponent(this.dispenserAnimator);
    this.dispenserAnimator.addClip(this.dispenserAnims["Idle_POAP"]);
    this.dispenserAnimator.addClip(this.dispenserAnims["Action_POAP"]);

    // Play the IDLE dispenser animation
    this.dispenserAnims["Idle_POAP"].play();

    // Create Button to claim POAP token
    this.buttonEntity = new Entity();
    this.buttonEntity.addComponent(this.buttonShape);
    this.buttonEntity.setParent(this);
    // Add the animator component and the button animation
    this.buttonEntity.addComponent(this.buttonAnimator);
    button.buttonAnimator.addClip(this.buttonAnims["buttonAction"]);
    this.buttonEntity.addComponent(
      new OnPointerDown(
        async (_e) => {
          this.buttonAnimator.getClip(this.buttonAnims["buttonAction"].clip).play();
          sounds.PlayOpenSound();
          

          if (!bEnablePoapClaim.bEnable) {
            debugMessage("Voting hasn't started yet.");
            return;
          }

          if ( this.testing ) {
            this.TestAirtableCalls();
            return;
          }

          // Trigger the POAP claim event
          void await this.makeTransaction();
          
        },
        { button: ActionButton.POINTER, hoverText: 'Submit your vote! \nClaim your POAP.', distance: 5 }
      )
    );

    // update count every 30 seconds
    this.addComponentOrReplace(new utils.Interval(30 * 1000, async () => {
      this.count = await this.AirtableClient.updateCount(voteID)
      log( `Updating count for ${voteName} to: ${this.count}` )
    }))

    // use messageBus to fire event on activeatePoap
    sceneMessageBus.on('activatePoap', () => {
      this.activate()
    })

  }

  activate(): void {
    const anim = this.dispenserAnimator

    anim.getClip(this.dispenserAnims["Action_POAP"].clip).play()

    this.addComponentOrReplace(
      new utils.Delay(4000, () => {
        anim.getClip(this.dispenserAnims["Action_POAP"].clip).stop()

        anim.getClip(this.dispenserAnims["Idle_POAP"].clip).play()
      })
    )
  }


  async getCaptcha(): Promise<string> {
    const captchaUUIDQuery = await signedFetch(`https://${this.poapServer}/captcha`, {
      method: 'POST'
    })
    const json = JSON.parse(captchaUUIDQuery.text)
    return json.data.uuid
  }

  async makeTransaction() {
    const userData = await getUserData()

    // no wallet
    if (!userData || !userData.hasConnectedWeb3) {
      log('no wallet')
      sounds.PlayCloseSound()

      boothUI.metamask()
      return
    }


    // Delay timer before claiming
      if (+this.createdTime > (new Date().setMinutes(new Date().getMinutes() - (timeDelay/1000)/60) )) {
      sounds.PlayCloseSound()
      boothUI.timerBeforeClaim(this.createdTime, timeDelay)
      return
    }


    if (this.bAlreadyAttempted) {
      // already attempted
      sounds.PlayCloseSound()
      boothUI.alreadyClaimed()
      return
    }

    this.bAlreadyAttempted = true
    const realm = await getCurrentRealm()

    try {
      const captchaUUID = await this.getCaptcha()
      const captchaResult = await boothUI.captcha(this.poapServer, captchaUUID)
      log("captcha result: ", captchaResult)
      if (captchaResult === undefined) {
        this.bAlreadyAttempted = false
        let prompt = new UI.OkPrompt(
            `Oops, there was an error with Captcha: \n"${captchaResult}",`,
            () => {
              sounds.PlayOpenSound()
              log(`continue`)
            },
            'Ok',
            true
        )
        return
      }
      const response = await this.claimCall(captchaResult, userData, realm)
      log(response)
      log("Claim Call response: ",response.status)
      const json = await response.json()
      log("JSON log: ", json)
      if (response.status === 200) { // success on claiming POAP

        // fire event to activatePoap and play claim sound
        sceneMessageBus.emit('activatePoap', {});
        sounds.PlayCoinSound();
        
        // Send data to Airtable
        log('Adding Voter!')
        let res = await this.AirtableClient.addVoter(this.voteID, userData.publicKey, userData.displayName, realm.displayName, new Date().toISOString().split('T')[0])
        
        switch (res.status) {
          
          case 200:
            let prompt = new UI.OkPrompt(
                "Congrats! You placed your vote!",
                () => {
                  sounds.PlayOpenSound()
                  log(`continue`)
                },
                'Awesome!',
                true
            );
            log(res.statusText);
            this.counterTextEntity.getComponent(TextShape).value = await this.AirtableClient.updateCount(this.voteID);
            break
          
          case 429:
            // add delay then try again
            new utils.Delay(30 * 1000, async () => {
              res = await this.AirtableClient.addVoter(this.voteID, userData.publicKey, userData.displayName, realm.displayName, new Date().toISOString().split('T')[0])
              log(res.status)

              if (res.status === 200) {
                //!**   Add an actual UI that requires the next button to be pressed!   **!/
                let prompt = new UI.OkPrompt(
                        "Congrats! You placed your vote!",
                        () => {
                          sounds.PlayOpenSound();
                          log(`continue`)
                        },
                        'Awesome!',
                        true
                )}
            });
            this.counterTextEntity.getComponent(TextShape).value = await this.AirtableClient.updateCount(this.voteID);
            break
          
          default:
            log(res.statusText);
            let promptDefault = new UI.OkPrompt(
                `Oops, there was an error: \n"${res.statusText}",`,
                () => { sounds.PlayCloseSound(); },
                'Ok',
                true
            )
            break

        }

        // show UI success message
        boothUI.viewSuccessMessage(
          json.data.event.name,
          json.data.event.image_url,
          1024,
          1024
        )
        /* sceneMessageBus.emit('activatePoap', {})
        // activate() // Play claim animation */

      /*} if (response.status === 500) { // error on claiming POAP
        let errorPrompt = new UI.OkPrompt(
            `Oops, there was an error with Captcha: \n"${response.statusText}",`,
            () => { },
            'Ok',
            true
        )
        UI.displayAnnouncement(`Oops, there was an error with Captcha: "${response.statusText}",`, 3)*/

      } else {
        sounds.PlayCloseSound()
        switch (json.error) {
          case 'Address already claimed a code for this event':
            let errorPrompt = new UI.OkPrompt(
                `You already claimed this event`,
                () => { },
                'Ok',
                true
            )
            break

          default:
            this.bAlreadyAttempted = false;
            let defaultPrompt = new UI.OkPrompt(
                `Oops, there was an error: \n"${json.error}"`,
                () => { sounds.PlayCloseSound() },
                'Ok',
                true
            )
            break
        }
      }
      
    } catch {
      this.bAlreadyAttempted = false
      log('Error fetching from POAP server ', this.poapServer)
      let defaultPrompt = new UI.OkPrompt(
          'Error fetching from POAP server. Try Again.',
          () => { sounds.PlayCloseSound() },
          'Ok',
          true
      )
    }

    return
  }

  async claimCall(
    captchaResult: string,
    userData: UserData,
    realm: Realm
  ) {
    const response = await fetch(`https://${this.poapServer}/claim/${this.eventUUID}`, {
      headers: { 'Content-Type': 'application/json' },
      method: 'POST',
      body: JSON.stringify({
        address: userData.publicKey,
        catalyst: realm.domain,
        room: realm.room,
        captcha: captchaResult
      })
    })
    return response
  }
  
  
  // -- TESTING FUNCTION -- //
  async TestAirtableCalls() {
    const userData = await getUserData()
    const realm = await getCurrentRealm()
    
    
    // Send data to Airtable
    log('Adding Voter!')
    let res = await this.AirtableClient.addVoter(this.voteID, userData.publicKey, userData.displayName, realm.displayName, new Date().toISOString().split('T')[0])

    switch (res.status) {
      case 200: //Add voter to Airtable, successful.
        let prompt = new UI.OkPrompt(
            "Congrats! You placed your vote!",
            () => {
              sounds.PlayOpenSound();
              log(`continue`);
            },
            'Awesome!',
            true
        );
        log(res.status);
        this.counterTextEntity.getComponent(TextShape).value = await this.AirtableClient.updateCount(this.voteID);
        break

      case 429: // Too many calls to Airtable.
        // add delay then try again
        new utils.Delay(30 * 1000, async () => {
          res = await this.AirtableClient.addVoter(this.voteID, userData.publicKey, userData.displayName, realm.displayName, new Date().toISOString().split('T')[0])
          log(res.status)

          if (res.status === 200) {
            //!**   Add an actual UI that requires the next button to be pressed!   **!/
            sounds.PlayCoinSound();
            let prompt = new UI.OkPrompt(
                "Congrats! You placed your vote!",
                () => {
                  sounds.PlayOpenSound();
                  log(`continue`)
                },
                'Awesome!',
                true
            )}
        });
        this.counterTextEntity.getComponent(TextShape).value = await this.AirtableClient.updateCount(this.voteID);
        break

      default:
        log(res.statusText);
        let promptDefault = new UI.OkPrompt(
            `Oops, there was an error: \n"${res.statusText}",`,
            () => { sounds.PlayCloseSound(); },
            'Ok',
            true
        )
        break

    }
  }


}



